{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"FormAction"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Root"},{"kind":"text","text":">"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This type can be used to eliminate the boilerplate that is typically incurred when working with"},{"type":"text","text":" "},{"type":"text","text":"multiple mutable fields on state."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, a settings screen may model its state with the following struct:"}]},{"type":"codeListing","syntax":null,"code":["struct SettingsState {","  var digest = Digest.daily","  var displayName = \"\"","  var enableNotifications = false","  var protectMyPosts = false","  var sendEmailNotifications = false","  var sendMobileNotifications = false","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each of these fields should be editable, and in the Composable Architecture this means that each"},{"type":"text","text":" "},{"type":"text","text":"field requires a corresponding action that can be sent to the store. Typically this comes in the"},{"type":"text","text":" "},{"type":"text","text":"form of an enum with a case per field:"}]},{"type":"codeListing","syntax":null,"code":["enum SettingsAction {","  case digestChanged(Digest)","  case displayNameChanged(String)","  case enableNotificationsChanged(Bool)","  case protectMyPostsChanged(Bool)","  case sendEmailNotificationsChanged(Bool)","  case sendMobileNotificationsChanged(Bool)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And we’re not even done yet. In the reducer we must now handle each action, which simply"},{"type":"text","text":" "},{"type":"text","text":"replaces the state at each field with a new value:"}]},{"type":"codeListing","syntax":null,"code":["let settingsReducer = Reducer<","  SettingsState, SettingsAction, SettingsEnvironment","> { state, action, environment in","  switch action {","  case let digestChanged(digest):","    state.digest = digest","    return .none","","  case let displayNameChanged(displayName):","    state.displayName = displayName","    return .none","","  case let enableNotificationsChanged(isOn):","    state.enableNotifications = isOn","    return .none","","  case let protectMyPostsChanged(isOn):","    state.protectMyPosts = isOn","    return .none","","  case let sendEmailNotificationsChanged(isOn):","    state.sendEmailNotifications = isOn","    return .none","","  case let sendMobileNotificationsChanged(isOn):","    state.sendMobileNotifications = isOn","    return .none","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"lot"}]},{"type":"text","text":" of boilerplate for something that should be simple. Luckily, we can dramatically"},{"type":"text","text":" "},{"type":"text","text":"eliminate this boilerplate using "},{"type":"codeVoice","code":"FormAction"},{"type":"text","text":". First, we can collapse all of these"},{"type":"text","text":" "},{"type":"text","text":"field-mutating actions into a single case that holds a "},{"type":"codeVoice","code":"FormAction"},{"type":"text","text":" generic over the reducer’s"},{"type":"text","text":" "},{"type":"text","text":"root "},{"type":"codeVoice","code":"SettingsState"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":null,"code":["enum SettingsAction {","  case form(FormAction<SettingsState>)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then, we can simplify the settings reducer by allowing the "},{"type":"codeVoice","code":"form"},{"type":"text","text":" method to handle these"},{"type":"text","text":" "},{"type":"text","text":"field mutations for us:"}]},{"type":"codeListing","syntax":null,"code":["let settingsReducer = Reducer<","  SettingsState, SettingsAction, SettingsEnvironment","> {","  switch action {","  case .form:","    return .none","  }","}",".form(action: \/SettingsAction.form)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Form actions are constructed and sent to the store by providing a writable key path from root"},{"type":"text","text":" "},{"type":"text","text":"state to the field being mutated. There is even a view store helper that simplifies this work."},{"type":"text","text":" "},{"type":"text","text":"You can derive a binding by specifying the key path and form action case:"}]},{"type":"codeListing","syntax":null,"code":["TextField(","  \"Display name\",","  text: viewStore.binding(keyPath: \\.displayName, send: SettingsAction.form)",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Should you need to layer additional functionality over your form, your reducer can pattern match"},{"type":"text","text":" "},{"type":"text","text":"the form action for a given key path:"}]},{"type":"codeListing","syntax":null,"code":["case .form(\\.displayName):","  \/\/ Validate display name","","case .form(\\.enableNotifications):","  \/\/ Return an authorization request effect"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Form actions can also be tested in much the same way regular actions are tested. Rather than"},{"type":"text","text":" "},{"type":"text","text":"send a specific action describing how a binding changed, such as "},{"type":"codeVoice","code":"displayNameChanged(\"Blob\")"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"you will send a "},{"type":"codeVoice","code":".form"},{"type":"text","text":" action that describes which key path is being set to what value, such"},{"type":"text","text":" "},{"type":"text","text":"as "},{"type":"codeVoice","code":".form(.set(\\.displayName, \"Blob\"))"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":null,"code":["let store = TestStore(","  initialState: SettingsState(),","  reducer: settingsReducer,","  environment: SettingsEnvironment(...)",")","","store.assert(","  .send(.form(.set(\\.displayName, \"Blob\"))) {","    $0.displayName = \"Blob\"","  },","  .send(.form(.set(\\.protectMyPosts, true))) {","    $0.protectMyPosts = true","  )",")"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/composablearchitecture\/formaction"],"traits":[{"interfaceLanguage":"swift"}]}],"relationshipsSections":[{"identifiers":["doc:\/\/co.pointfree.ComposableArchitecture\/SQ"],"kind":"relationships","title":"Conforms To","type":"conformsTo"}],"identifier":{"url":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"An action that describes simple mutations to some root state at a writable key path."}],"kind":"symbol","metadata":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"FormAction"}],"title":"FormAction","roleHeading":"Structure","role":"symbol","symbolKind":"struct","externalID":"s:22ComposableArchitecture10FormActionV","modules":[{"name":"ComposableArchitecture"}],"navigatorTitle":[{"kind":"identifier","text":"FormAction"}]},"hierarchy":{"paths":[["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"topicSections":[{"title":"Operators","identifiers":["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/==(_:_:)","doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/~=(_:_:)"]},{"title":"Instance Properties","identifiers":["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/keyPath"]},{"title":"Instance Methods","identifiers":["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/pullback(_:)"]},{"title":"Type Methods","identifiers":["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/set(_:_:)"]},{"title":"Default Implementations","identifiers":["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/Equatable-Implementations"],"generated":true}],"references":{"doc://co.pointfree.ComposableArchitecture/SQ":{"type":"unresolvable","title":"Swift.Equatable","identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/SQ"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/FormAction":{"role":"symbol","title":"FormAction","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"FormAction"}],"abstract":[{"type":"text","text":"An action that describes simple mutations to some root state at a writable key path."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"FormAction"}],"url":"\/documentation\/composablearchitecture\/formaction"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/FormAction/keyPath":{"role":"symbol","title":"keyPath","fragments":[{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"keyPath"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"PartialKeyPath","preciseIdentifier":"s:s14PartialKeyPathC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Root"},{"kind":"text","text":">"}],"abstract":[],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/keyPath","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/formaction\/keypath"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/FormAction/pullback(_:)":{"role":"symbol","title":"pullback(_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"pullback"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"NewRoot"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"WritableKeyPath","preciseIdentifier":"s:s15WritableKeyPathC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"NewRoot"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Root"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"FormAction","preciseIdentifier":"s:22ComposableArchitecture10FormActionV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"NewRoot"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Transforms a form action over some root state to some other type of root state given a key"},{"type":"text","text":" "},{"type":"text","text":"path."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/pullback(_:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/formaction\/pullback(_:)"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/FormAction/~=(_:_:)":{"role":"symbol","title":"~=(_:_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"~="},{"kind":"text","text":" "},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Value"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"WritableKeyPath","preciseIdentifier":"s:s15WritableKeyPathC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Root"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Value"},{"kind":"text","text":">, "},{"kind":"typeIdentifier","text":"FormAction","preciseIdentifier":"s:22ComposableArchitecture10FormActionV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Root"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"}],"abstract":[],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/~=(_:_:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/formaction\/~=(_:_:)"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture":{"role":"collection","title":"ComposableArchitecture","abstract":[],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/FormAction/==(_:_:)":{"role":"symbol","title":"==(_:_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"=="},{"kind":"text","text":" "},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"FormAction","preciseIdentifier":"s:22ComposableArchitecture10FormActionV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Root"},{"kind":"text","text":">, "},{"kind":"typeIdentifier","text":"FormAction","preciseIdentifier":"s:22ComposableArchitecture10FormActionV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Root"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"}],"abstract":[],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/==(_:_:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/formaction\/==(_:_:)"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/FormAction/set(_:_:)":{"role":"symbol","title":"set(_:_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"set"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Value"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"WritableKeyPath","preciseIdentifier":"s:s15WritableKeyPathC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Root"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Value"},{"kind":"text","text":">, "},{"kind":"typeIdentifier","text":"Value"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"FormAction","preciseIdentifier":"s:22ComposableArchitecture10FormActionV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Root"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Returns an action that describes simple mutations to some root state at a writable key path."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/set(_:_:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/formaction\/set(_:_:)"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/FormAction/Equatable-Implementations":{"role":"collectionGroup","title":"Equatable Implementations","abstract":[],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/FormAction\/Equatable-Implementations","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/formaction\/equatable-implementations"}}}